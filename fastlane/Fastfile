# Fastlane automation for sept122025 iOS builds
# Provides lanes to sync signing assets, archive the app, and upload to TestFlight

require 'openssl'

def require_env!(key, hint: nil)
  value = ENV[key]
  return value unless value.to_s.strip.empty?

  message = "Environment variable #{key} is required"
  message += " (#{hint})" if hint
  UI.user_error!(message)
end

default_platform(:ios)

BUNDLE_ID = ENV['BUNDLE_ID'] || ENV['APP_IDENTIFIER'] || require_env!('BUNDLE_ID', hint: 'e.g., com.example.app')
SCHEME = ENV['IOS_SCHEME'] || 'App'
WORKSPACE = ENV['IOS_WORKSPACE_PATH'] || './ios/App.xcworkspace'
PROJECT = ENV['IOS_PROJECT_PATH'] || './ios/App.xcodeproj'
IPA_PATH = ENV['IOS_IPA_OUTPUT_PATH'] || './build/App.ipa'
TEAM_ID = ENV['APPLE_TEAM_ID'] || ENV['TEAM_ID'] || require_env!('APPLE_TEAM_ID', hint: 'fetch from Apple Developer portal')
API_KEY_ENV_KEYS = %w[
  APP_STORE_CONNECT_API_KEY_ID
  APP_STORE_CONNECT_ISSUER_ID
  APP_STORE_CONNECT_API_KEY_CONTENT
  APP_STORE_CONNECT_API_KEY_PATH
  APP_STORE_CONNECT_API_KEY_JSON
]

def disable_api_key_env!
  return if @api_key_env_disabled

  API_KEY_ENV_KEYS.each do |key|
    next unless ENV.key?(key)
    ENV["BACKUP_#{key}"] = ENV[key]
    ENV.delete(key)
  end

  @api_key_env_disabled = true
  UI.important('Disabled App Store Connect API key environment variables; relying on Apple ID auth')
end

def configure_api_key
  json_key = ENV['APP_STORE_CONNECT_API_KEY_JSON']
  begin
    return app_store_connect_api_key(json_key: json_key) if json_key
  rescue OpenSSL::PKey::ECError => e
    UI.error("Failed to configure App Store Connect API key from JSON: #{e.message}")
    UI.important('Falling back to Apple ID authentication')
    disable_api_key_env!
    return nil
  end

  key_path = ENV['APP_STORE_CONNECT_API_KEY_PATH']
  if key_path
    begin
      return app_store_connect_api_key(
        key_id: ENV.fetch('APP_STORE_CONNECT_API_KEY_ID'),
        issuer_id: ENV.fetch('APP_STORE_CONNECT_ISSUER_ID'),
        key_filepath: key_path
      )
    rescue OpenSSL::PKey::ECError => e
      UI.error("Failed to configure App Store Connect API key from file #{key_path}: #{e.message}")
      UI.important('Falling back to Apple ID authentication')
      disable_api_key_env!
      return nil
    end
  end

  key_content = ENV['APP_STORE_CONNECT_API_KEY_CONTENT']
  return nil unless key_content

  options = {
    key_id: ENV.fetch('APP_STORE_CONNECT_API_KEY_ID'),
    issuer_id: ENV.fetch('APP_STORE_CONNECT_ISSUER_ID'),
    key_content: key_content.strip
  }

  begins_with_pem_header = options[:key_content].start_with?('-----BEGIN')

  if begins_with_pem_header
    begin
      return app_store_connect_api_key(**options)
    rescue OpenSSL::PKey::ECError => e
      UI.error("Failed to configure App Store Connect API key from PEM content: #{e.message}")
      UI.important('Falling back to Apple ID authentication')
      disable_api_key_env!
      return nil
    end
  end

  begin
    return app_store_connect_api_key(**options.merge(is_key_content_base64: true))
  rescue OpenSSL::PKey::ECError
    UI.important('Retrying App Store Connect API key using raw .p8 content (not base64 encoded)')
    begin
      return app_store_connect_api_key(**options)
    rescue OpenSSL::PKey::ECError => e
      UI.error("Failed to configure App Store Connect API key: #{e.message}")
      UI.important('Continuing without API key ‚Äì Fastlane will use Apple ID session instead')
      disable_api_key_env!
      return nil
    end
  end
end

platform :ios do
  desc 'Create the App ID and App Store Connect record if they do not exist yet'
  lane :bootstrap_app do
    app_name = ENV['APP_NAME'] || 'sept122025'
    sku = ENV['APP_SKU'] || "sept122025-#{Time.now.strftime('%Y%m%d%H%M%S')}"
    primary_language = ENV['APP_PRIMARY_LANGUAGE'] || 'English'

    UI.message("üöß Ensuring App ID #{BUNDLE_ID} exists for team #{TEAM_ID}")

    produce(
      app_identifier: BUNDLE_ID,
      bundle_identifier: BUNDLE_ID,
      app_name: app_name,
      sku: sku,
      primary_language: primary_language,
      team_id: TEAM_ID,
      skip_itc: false,
      enable_services: {
        app_group: 'off',
        i_cloud: 'off',
        push_notification: 'off'
      }
    )

    UI.success("‚úÖ App ID and App Store Connect entry are configured for #{BUNDLE_ID}")
  end

  desc 'Ensure signing assets are available via match'
  lane :sync_signing do
    api_key = configure_api_key

    git_url = ENV['MATCH_GIT_URL'] || require_env!('MATCH_GIT_URL', hint: 'set to your Match storage repository')

    match_options = {
      type: 'appstore',
      readonly: ENV['CI'] == 'true',
      app_identifier: [BUNDLE_ID],
      git_url: git_url,
      git_branch: ENV['MATCH_GIT_BRANCH'] || 'main',
      username: ENV['FASTLANE_USER'] || ENV['APPLE_ID']
    }

    match_options[:api_key] = api_key if api_key

    begin
      match(**match_options)
    rescue OpenSSL::PKey::ECError => e
      UI.error("fastlane match failed while using API key: #{e.message}")
      disable_api_key_env!
      match_options.delete(:api_key)
      match(**match_options)
    end
  end

  desc 'Archive the iOS app for distribution'
  lane :build do
    sync_signing

    build_number = ENV['BUILD_NUMBER'] || Time.now.strftime('%y%m%d%H%M%S')
    increment_build_number(
      xcodeproj: PROJECT,
      build_number: build_number
    )
    ENV['BUILD_NUMBER'] = build_number
    lane_context[SharedValues::BUILD_NUMBER] = build_number

    update_project_team(
      path: PROJECT,
      teamid: TEAM_ID
    )

    profile_mapping = lane_context[SharedValues::MATCH_PROVISIONING_PROFILE_MAPPING] || {}
    profile_name = profile_mapping[BUNDLE_ID.to_sym] || profile_mapping[BUNDLE_ID] || "match AppStore #{BUNDLE_ID}"
    profile_uuid = ENV["sigh_#{BUNDLE_ID.gsub('.', '_')}_appstore"]

    update_code_signing_settings(
      path: PROJECT,
      use_automatic_signing: false,
      team_id: TEAM_ID,
      bundle_identifier: BUNDLE_ID,
      profile_name: profile_name,
      profile_uuid: profile_uuid,
      code_sign_identity: 'Apple Distribution'
    )

    build_app(
      workspace: WORKSPACE,
      scheme: SCHEME,
      configuration: 'Release',
      clean: true,
      export_method: 'app-store',
      output_directory: './build',
      output_name: File.basename(IPA_PATH),
      export_options: {
        method: 'app-store',
        teamID: TEAM_ID,
        signingStyle: 'manual',
        signingCertificate: 'Apple Distribution',
        provisioningProfiles: { BUNDLE_ID => profile_name },
        compileBitcode: false,
        uploadBitcode: false,
        uploadSymbols: true
      }
    )

    UI.success("Created IPA at #{IPA_PATH}")
  end

  desc 'Upload the most recent IPA to TestFlight'
  lane :upload_testflight do |options|
    project_root = if FastlaneCore::FastlaneFolder.path
                     File.expand_path('..', FastlaneCore::FastlaneFolder.path)
                   else
                     Dir.pwd
                   end
    ipa_source = options[:ipa_path] || Actions.lane_context[SharedValues::IPA_OUTPUT_PATH] || IPA_PATH
    ipa_path = File.expand_path(ipa_source, project_root)
    UI.user_error!("IPA not found at #{ipa_path}") unless File.exist?(ipa_path)

    api_key = configure_api_key

    pilot(
      ipa: ipa_path,
      api_key: api_key,
      skip_waiting_for_build_processing: ENV['SKIP_WAITING'] == 'true',
      distribute_external: ENV['DISTRIBUTE_EXTERNAL'] == 'true',
      changelog: ENV['CHANGELOG']
    )
  end

  desc 'Build and upload to TestFlight'
  lane :deploy do
    build
    upload_testflight
    begin
      version = get_version_number(
        xcodeproj: PROJECT,
        target: SCHEME
      )
      build_number = lane_context[SharedValues::BUILD_NUMBER] || get_build_number(
        xcodeproj: PROJECT,
        target: SCHEME
      )
      tag_name = "releases/v#{version}/#{build_number}"
      sh("git tag #{tag_name}")
      sh("git push origin #{tag_name}")
      UI.success("üè∑ Tagged release as #{tag_name}")
    rescue => e
      UI.important("‚ö†Ô∏è Failed to create/push tag: #{e.message}")
    end
  end

  desc 'Upload an already-built IPA to TestFlight'
  lane :upload do |options|
    ipa_path = options[:ipa_path] || IPA_PATH
    upload_testflight(ipa_path: ipa_path)
  end

  desc 'Run validations without building'
  lane :doctor do
    sync_signing
    UI.success('Signing and App Store Connect credentials look good')
  end
end
